generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum TenantType {
  ADMINISTRADORA
  EDIFICIO_AUTOGESTION
}

enum Role {
  SUPER_ADMIN
  TENANT_OWNER
  TENANT_ADMIN
  OPERATOR
  RESIDENT
}

enum ScopeType {
  TENANT
  BUILDING
  UNIT
}

enum UnitOccupantRole {
  OWNER
  RESIDENT
}

// ============================================================================
// FINANZAS (Charges, Payments, Allocations)
// ============================================================================

enum ChargeStatus {
  PENDING
  PARTIAL
  PAID
  CANCELED
}

enum PaymentStatus {
  SUBMITTED
  APPROVED
  REJECTED
  RECONCILED
}

enum PaymentMethod {
  TRANSFER
  CASH
  CARD
  ONLINE
}

enum ChargeType {
  COMMON_EXPENSE
  EXTRAORDINARY
  FINE
  CREDIT
  OTHER
}

model Tenant {
  id                    String                 @id @default(cuid())
  name                  String                 @unique
  type                  TenantType
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt

  // Branding
  brandName             String?                // Commercial name (different from tenant name)
  logoFileId            String?                // FK to File, if uploaded
  primaryColor          String?                // Hex color: #123456
  secondaryColor        String?                // Optional secondary color
  theme                 String?                // "light" | "dark" | "system"
  emailFooter           String?                // For future email communications

  // Relations
  memberships           Membership[]
  buildings             Building[]
  auditLogs             AuditLog[]
  subscription          Subscription?
  paymentVerifications  PaymentVerification[]
  tickets               Ticket[]
  ticketComments        TicketComment[]
  communications        Communication[]
  communicationTargets  CommunicationTarget[]
  communicationReceipts CommunicationReceipt[]
  files                 File[]
  documents             Document[]
  vendors               Vendor[]
  vendorAssignments     VendorAssignment[]
  quotes                Quote[]
  workOrders            WorkOrder[]
  charges               Charge[]
  payments              Payment[]
  paymentAllocations    PaymentAllocation[]
  invitations           Invitation[]
  onboardingState       OnboardingState?
  emailLogs             EmailLog[]
  supportTickets        SupportTicket[]
  notifications         Notification[]
  aiInteractionLogs     AiInteractionLog[]
  dailyAiUsage          TenantDailyAiUsage[]
  aiBudget              TenantAiBudget?
  monthlyAiUsage        TenantMonthlyAiUsage[]
}

model User {
  id                    String                 @id @default(cuid())
  email                 String                 @unique
  name                  String
  passwordHash          String
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  memberships           Membership[]
  unitOccupants         UnitOccupant[]
  auditLogs             AuditLog[]
  ticketsCreated        Ticket[]               @relation("TicketCreatedBy")
  ticketComments        TicketComment[]        @relation("TicketCommentAuthor")
  communicationReceipts CommunicationReceipt[]
  paymentsCreated       Payment[]              @relation("PaymentCreatedBy")
  supportTicketsCreated SupportTicket[]        @relation("SupportTicketCreatedBy")
  supportTicketsAssigned SupportTicket[]       @relation("SupportTicketAssignedTo")
  supportTicketComments SupportTicketComment[] @relation("SupportTicketCommentAuthor")
  notifications         Notification[]         @relation("UserNotifications")
  aiInteractionLogs     AiInteractionLog[]
}

model Membership {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant                Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user                  User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  roles                 MembershipRole[]
  assignedTickets       Ticket[]
  communicationsCreated Communication[]
  filesCreated          File[]
  documentsCreated      Document[]
  assignedWorkOrders    WorkOrder[]           @relation("WorkOrderAssignedTo")
  chargesCreatedBy      Charge[]
  paymentsReviewedBy    Payment[]
  invitationsSent       Invitation[]          @relation("InvitationsSent")
  aiInteractionLogs     AiInteractionLog[]

  @@unique([userId, tenantId])
  @@index([tenantId])
  @@index([userId])
  userContext      UserContext?
}

model UserContext {
  id                String   @id @default(cuid())
  membershipId      String   @unique
  activeBuildingId  String?
  activeUnitId      String?
  updatedAt         DateTime @updatedAt

  membership Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  building   Building?  @relation("UserContextBuilding", fields: [activeBuildingId], references: [id], onDelete: SetNull)
  unit       Unit?      @relation("UserContextUnit", fields: [activeUnitId], references: [id], onDelete: SetNull)

  @@index([membershipId])
  @@index([activeBuildingId])
  @@index([activeUnitId])
}

model MembershipRole {
  id              String     @id @default(cuid())
  membershipId    String
  role            Role
  scopeType       ScopeType  @default(TENANT)
  scopeBuildingId String?
  scopeUnitId     String?

  membership    Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  scopeBuilding Building?  @relation("BuildingMembershipRoles", fields: [scopeBuildingId], references: [id], onDelete: SetNull)
  scopeUnit     Unit?      @relation("UnitMembershipRoles", fields: [scopeUnitId], references: [id], onDelete: SetNull)

  @@index([membershipId, role])
  @@index([scopeType, scopeBuildingId])
  @@index([scopeType, scopeUnitId])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

model Invitation {
  id                    String           @id @default(cuid())
  tenantId              String
  email                 String
  tokenHash             String           @unique
  roles                 Json // string[] of Role enum, e.g. ["OPERATOR"]
  invitedByMembershipId String
  status                InvitationStatus @default(PENDING)
  expiresAt             DateTime
  createdAt             DateTime         @default(now())
  acceptedAt            DateTime?

  tenant              Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invitedByMembership Membership @relation("InvitationsSent", fields: [invitedByMembershipId], references: [id], onDelete: Cascade)

  @@unique([tenantId, email, status])
  @@index([tenantId])
  @@index([tokenHash])
  @@index([status])
}

model Building {
  id        String   @id @default(cuid())
  tenantId  String
  name      String
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant                Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  units                 Unit[]
  tickets               Ticket[]
  communications        Communication[]
  documents             Document[]
  vendorAssignments     VendorAssignment[]
  quotes                Quote[]
  workOrders            WorkOrder[]
  charges               Charge[]
  payments              Payment[]
  membershipRoles       MembershipRole[]      @relation("BuildingMembershipRoles")
  userContexts          UserContext[]         @relation("UserContextBuilding")

  @@unique([tenantId, name])
  @@index([tenantId])
}

model Unit {
  id              String   @id @default(cuid())
  buildingId      String
  code            String
  label           String?
  unitType        String   @default("APARTMENT") // APARTMENT, HOUSE, OFFICE, STORAGE, PARKING
  occupancyStatus String   @default("UNKNOWN") // UNKNOWN, VACANT, OCCUPIED
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  building        Building         @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  unitOccupants   UnitOccupant[]
  tickets         Ticket[]
  documents       Document[]
  charges         Charge[]
  payments        Payment[]
  membershipRoles MembershipRole[] @relation("UnitMembershipRoles")
  userContexts    UserContext[]    @relation("UserContextUnit")

  @@unique([buildingId, code])
  @@index([buildingId])
}

model UnitOccupant {
  id        String           @id @default(cuid())
  unitId    String
  userId    String
  role      UnitOccupantRole
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  unit Unit @relation(fields: [unitId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([unitId, userId, role])
  @@index([unitId])
  @@index([userId])
}

// ============================================================================
// AUDIT LOGGING (OPCIÓN A — SUPER_ADMIN Backend)
// ============================================================================

enum AuditAction {
  // SUPER_ADMIN
  TENANT_CREATE
  TENANT_UPDATE
  TENANT_DELETE
  TENANT_BRANDING_UPDATED
  SUBSCRIPTION_CREATE
  SUBSCRIPTION_UPDATE
  SUBSCRIPTION_CANCEL
  SUBSCRIPTION_PAST_DUE
  USER_CREATE
  USER_DELETE
  OTHER
  // AUTH
  AUTH_LOGIN
  AUTH_LOGOUT
  AUTH_FAILED_LOGIN
  MEMBERSHIP_INVITE_SENT
  MEMBERSHIP_INVITE_ACCEPTED
  MEMBERSHIP_INVITE_REVOKED
  MEMBERSHIP_INVITE_RESENT
  MEMBERSHIP_INVITE_EXPIRED
  MEMBERSHIP_ROLE_CHANGED
  ROLE_ASSIGNED
  ROLE_REMOVED
  // IMPERSONATION
  IMPERSONATION_START
  IMPERSONATION_END
  // BUILDING/UNIT
  BUILDING_CREATE
  BUILDING_UPDATE
  BUILDING_DELETE
  UNIT_CREATE
  UNIT_UPDATE
  UNIT_DELETE
  OCCUPANT_ASSIGN
  OCCUPANT_REMOVE
  // TICKETS
  TICKET_CREATE
  TICKET_UPDATE
  TICKET_STATUS_CHANGE
  TICKET_ASSIGN
  TICKET_COMMENT_ADD
  TICKET_DELETE
  // COMMUNICATIONS
  COMMUNICATION_CREATE_DRAFT
  COMMUNICATION_EDIT_DRAFT
  COMMUNICATION_SEND
  COMMUNICATION_READ
  // DOCUMENTS
  FILE_UPLOADED
  DOCUMENT_CREATE
  DOCUMENT_VISIBILITY_CHANGED
  DOCUMENT_DOWNLOADED
  DOCUMENT_DELETE
  // FINANCE
  CHARGE_CREATE
  CHARGE_CANCEL
  PAYMENT_SUBMIT
  PAYMENT_APPROVE
  PAYMENT_REJECT
  PAYMENT_ALLOCATE
  ALLOCATION_DELETE
  // VENDORS/OPS
  VENDOR_CREATE
  VENDOR_UPDATE
  VENDOR_DELETE
  VENDOR_ASSIGN
  VENDOR_UNASSIGN
  QUOTE_CREATE
  QUOTE_STATUS_CHANGE
  WORK_ORDER_CREATE
  WORK_ORDER_STATUS_CHANGE
  // SUPPORT TICKETS
  SUPPORT_TICKET_CREATE
  SUPPORT_TICKET_UPDATE
  SUPPORT_TICKET_STATUS_CHANGE
  SUPPORT_TICKET_ASSIGN
  SUPPORT_TICKET_COMMENT_ADD
  SUPPORT_TICKET_CLOSE
  // NOTIFICATIONS
  NOTIFICATION_CREATED
  NOTIFICATION_READ
  NOTIFICATION_DELETED
  // DEMO SEED
  DEMO_SEED_CREATED
  REPORT_EXPORTED
  // AI ASSISTANT
  AI_INTERACTION
  AI_BUDGET_WARNED
  AI_BUDGET_BLOCKED
  AI_BUDGET_UPDATED
  AI_DEGRADED_BUDGET
}

model AuditLog {
  id                  String      @id @default(cuid())
  tenantId            String? // Nullable: SUPER_ADMIN actions are tenant-scoped, global actions are null
  actorUserId         String? // Nullable: system actions may have no actor
  actorMembershipId   String? // NEW: Link to Membership for tenant-scoped actions
  action              AuditAction
  entity              String // "Tenant", "Subscription", "User", "Ticket", "Building", etc.
  entityId            String // ID of the resource affected
  metadata            Json? // before/after values, details, request ID
  createdAt           DateTime    @default(now())

  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: SetNull)
  actor  User?   @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([actorUserId])
  @@index([action])
  @@index([createdAt])
  @@index([entity])
}

// ============================================================================
// BILLING (OPCIÓN A2 — Foundation for SaaS)
// ============================================================================

enum BillingPlanId {
  FREE
  BASIC
  PRO
  ENTERPRISE
}

enum SubscriptionStatus {
  TRIAL // Free trial period
  ACTIVE // Currently active
  PAST_DUE // Payment failed, but not canceled
  CANCELED // Canceled by user or admin
  EXPIRED // Trial ended without conversion
}

enum PaymentVerificationStatus {
  PENDING // Waiting for admin approval
  APPROVED // Admin approved the payment
  REJECTED // Admin rejected the payment
}

model BillingPlan {
  id           String        @id @default(cuid())
  planId       BillingPlanId @unique // Enum: FREE, BASIC, PRO, ENTERPRISE
  name         String // "Free", "Basic Plan", etc.
  description  String?
  monthlyPrice Int           @default(0) // in cents (0 = free)

  // Entitlements (A2)
  maxBuildings Int @default(1)
  maxUnits     Int @default(10)
  maxUsers     Int @default(3)
  maxOccupants Int @default(50)

  // Features flags
  canExportReports  Boolean @default(false)
  canBulkOperations Boolean @default(false)
  canUseAI          Boolean @default(false)
  supportLevel      String  @default("COMMUNITY") // COMMUNITY, EMAIL, PRIORITY

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions Subscription[]

  @@index([planId])
}

model Subscription {
  id       String             @id @default(cuid())
  tenantId String             @unique // One active subscription per tenant
  planId   String // Foreign key to BillingPlan.id
  status   SubscriptionStatus @default(TRIAL)

  // Period tracking (for billing cycles)
  currentPeriodStart DateTime  @default(now())
  currentPeriodEnd   DateTime? // Null for active, set on cancel
  trialEndDate       DateTime? // Null if not in trial

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant    Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  plan      BillingPlan             @relation(fields: [planId], references: [id], onDelete: Restrict)
  events    SubscriptionEvent[]
  payments  PaymentVerification[]

  @@index([tenantId])
  @@index([planId])
  @@index([status])
}

model SubscriptionEvent {
  id             String   @id @default(cuid())
  subscriptionId String
  eventType      String // "CREATED", "UPGRADED", "DOWNGRADED", "CANCELED", "RENEWED"
  prevPlanId     String? // For upgrades/downgrades
  newPlanId      String? // For upgrades/downgrades
  metadata       Json? // Extra data (reason, etc.)
  createdAt      DateTime @default(now())

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([eventType])
  @@index([createdAt])
}

model PaymentVerification {
  id               String                      @id @default(cuid())
  tenantId         String
  subscriptionId   String
  amount           Decimal                     @db.Decimal(10, 2) // Amount to pay
  currency         String                      @default("USD") // USD, ARS, COP, etc.
  status           PaymentVerificationStatus   @default(PENDING)

  // Payment reference (for manual verification)
  reference        String? // User provides this in transfer: "BUILDINGOS-[TENANT_ID]"
  bankDetails      String? // Which account they should send to

  // Admin approval
  approvedByUserId String? // SUPER_ADMIN who approved
  approvedAt       DateTime?
  rejectionReason  String? // If rejected
  rejectedAt       DateTime?

  // Metadata
  metadata         Json? // Extra data (receipt link, notes, etc.)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([subscriptionId])
  @@index([status])
  @@index([createdAt])
}

// ============================================================================
// TICKETS (MVP — Maintenance requests / Reclamos)
// ============================================================================

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

model Ticket {
  id                     String  @id @default(cuid())
  tenantId               String
  buildingId             String
  unitId                 String? // Optional: ticket may be building-wide
  createdByUserId        String
  assignedToMembershipId String? // Optional: ticket may not be assigned

  title       String
  description String
  category    String // "MAINTENANCE", "REPAIR", "CLEANING", "COMPLAINT", etc.
  priority    TicketPriority @default(MEDIUM)
  status      TicketStatus   @default(OPEN)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  closedAt  DateTime?

  // Relations
  tenant     Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  building   Building        @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  unit       Unit?           @relation(fields: [unitId], references: [id], onDelete: SetNull)
  createdBy  User            @relation("TicketCreatedBy", fields: [createdByUserId], references: [id], onDelete: Cascade)
  assignedTo Membership?     @relation(fields: [assignedToMembershipId], references: [id], onDelete: SetNull)
  comments   TicketComment[]
  quotes     Quote[]
  workOrders WorkOrder[]

  @@index([tenantId, buildingId, status])
  @@index([assignedToMembershipId, status])
  @@index([unitId, status])
}

model TicketComment {
  id           String @id @default(cuid())
  tenantId     String
  ticketId     String
  authorUserId String

  body      String
  createdAt DateTime @default(now())

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author User   @relation("TicketCommentAuthor", fields: [authorUserId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([tenantId])
}

// ============================================================================
// SUPPORT TICKETS (SaaS Customer Support)
// ============================================================================

enum SupportTicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SupportTicketCategory {
  BILLING
  FEATURE_REQUEST
  BUG_REPORT
  ACCOUNT_ISSUE
  TECHNICAL_SUPPORT
  OTHER
}

enum SupportTicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model SupportTicket {
  id              String                  @id @default(cuid())
  tenantId        String
  createdByUserId String
  assignedToUserId String?

  title           String
  description     String
  category        SupportTicketCategory   @default(OTHER)
  priority        SupportTicketPriority   @default(MEDIUM)
  status          SupportTicketStatus     @default(OPEN)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  resolvedAt DateTime?
  closedAt DateTime?

  // Relations
  tenant    Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy User    @relation("SupportTicketCreatedBy", fields: [createdByUserId], references: [id], onDelete: Cascade)
  assignedTo User?  @relation("SupportTicketAssignedTo", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  comments  SupportTicketComment[]

  @@index([tenantId, status])
  @@index([tenantId, createdAt])
  @@index([tenantId, createdByUserId])
  @@index([assignedToUserId])
}

model SupportTicketComment {
  id              String @id @default(cuid())
  supportTicketId String
  authorUserId    String

  body      String
  createdAt DateTime @default(now())

  // Relations
  supportTicket SupportTicket @relation(fields: [supportTicketId], references: [id], onDelete: Cascade)
  author        User          @relation("SupportTicketCommentAuthor", fields: [authorUserId], references: [id], onDelete: Cascade)

  @@index([supportTicketId])
  @@index([authorUserId])
}

// ============================================================================
// COMMUNICATIONS (MVP — Comunicados / Announcements)
// ============================================================================

enum CommunicationChannel {
  IN_APP
  EMAIL
  WHATSAPP
  PUSH
}

enum CommunicationStatus {
  DRAFT
  SCHEDULED
  SENT
}

enum CommunicationTargetType {
  ALL_TENANT
  BUILDING
  UNIT
  ROLE
}

model Communication {
  id         String  @id @default(cuid())
  tenantId   String
  buildingId String? // Nullable: comunicado puede ser cross-building o de un edificio específico

  title   String
  body    String
  channel CommunicationChannel
  status  CommunicationStatus  @default(DRAFT)

  createdByMembershipId String
  scheduledAt           DateTime?
  sentAt                DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant              Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  building            Building?              @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  createdByMembership Membership             @relation(fields: [createdByMembershipId], references: [id], onDelete: Cascade)
  targets             CommunicationTarget[]
  receipts            CommunicationReceipt[]

  @@index([tenantId, status])
  @@index([tenantId, buildingId, status])
  @@index([createdByMembershipId])
}

model CommunicationTarget {
  id              String @id @default(cuid())
  tenantId        String
  communicationId String

  targetType CommunicationTargetType
  targetId   String? // buildingId/unitId/roleCode según targetType

  createdAt DateTime @default(now())

  // Relations
  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  communication Communication @relation(fields: [communicationId], references: [id], onDelete: Cascade)

  @@index([communicationId])
  @@index([tenantId, targetType])
}

model CommunicationReceipt {
  id              String @id @default(cuid())
  tenantId        String
  communicationId String
  userId          String

  deliveredAt DateTime?
  readAt      DateTime?

  createdAt DateTime @default(now())

  // Relations
  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  communication Communication @relation(fields: [communicationId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([communicationId, userId])
  @@index([tenantId, userId, readAt])
  @@index([communicationId, readAt])
}

// ============================================================================
// DOCUMENTS & FILES (MVP — Documentos, Reglas, Actas, Contratos, etc.)
// ============================================================================

enum DocumentCategory {
  RULES // Reglamento/Normas
  MINUTES // Actas de asambleas
  CONTRACT // Contratos
  BUDGET // Presupuestos
  INVOICE // Facturas
  RECEIPT // Recibos/Comprobantes
  OTHER // Otro
}

enum DocumentVisibility {
  TENANT_ADMINS // Solo admins del tenant
  RESIDENTS // Visibles a residents (y admins)
  PRIVATE // Solo quien lo creó (y admins)
}

// ============================================================================
// VENDORS & OPERATIONS (MVP — Proveedores, Presupuestos, Órdenes de Trabajo)
// ============================================================================

enum QuoteStatus {
  REQUESTED // Presupuesto solicitado
  RECEIVED // Presupuesto recibido del proveedor
  APPROVED // Presupuesto aprobado
  REJECTED // Presupuesto rechazado
}

enum WorkOrderStatus {
  OPEN // Orden abierta / creada
  IN_PROGRESS // Orden en proceso
  DONE // Orden completada
  CANCELLED // Orden cancelada
}

// ============================================================================
// File: Metadata de archivos almacenados en MinIO
// Relación 1:1 con Document (cada documento tiene exactamente 1 archivo)
// ON DELETE: CUANDO se borra Document, se borra File (y se debe limpiar MinIO)
// ============================================================================
model File {
  id       String @id @default(cuid())
  tenantId String

  // MinIO metadata
  bucket       String // Bucket name in MinIO
  objectKey    String // Full path/key in MinIO (e.g., "tenant-a/documents/rules.pdf")
  originalName String // Original filename (for download)
  mimeType     String // MIME type (e.g., "application/pdf")
  size         Int // File size in bytes
  checksum     String? // SHA-256 or other hash for integrity check (optional)

  // Audit trail
  createdByMembershipId String? // Who uploaded the file (nullable for system uploads)
  createdAt             DateTime @default(now())

  // Relations
  tenant              Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdByMembership Membership? @relation(fields: [createdByMembershipId], references: [id], onDelete: SetNull)
  document            Document? // 1:1 relation (back-reference, defined in Document)
  quotes              Quote[] // 0..N relation (a file can be associated with multiple quotes, or none)
  paymentProofs       Payment[] // 0..N relation (payment proof files)

  @@unique([tenantId, bucket, objectKey])
  @@index([tenantId, createdAt])
  @@index([tenantId, objectKey])
}

// ============================================================================
// Document: Metadata y permisos de documentos (reglas, actas, contratos, etc.)
// Relación 1:1 con File (cada documento tiene exactamente 1 archivo)
//
// REGLA: Document debe estar asociado a EXACTAMENTE uno de:
//   A) buildingId (documento de edificio específico)
//   B) unitId (documento de unidad específica)
//   C) Ninguno (documento de tenant-wide, aplica a todo el tenant)
//
// Validación debe hacerse en la aplicación/servicio (Prisma no lo garantiza solo)
// ============================================================================
model Document {
  id       String @id @default(cuid())
  tenantId String
  fileId   String @unique // 1:1 relation with File

  title      String // Display name
  category   DocumentCategory
  visibility DocumentVisibility @default(TENANT_ADMINS)

  // Scope: debe ser exactamente uno de buildingId, unitId, o ninguno
  buildingId String? // If building-scoped
  unitId     String? // If unit-scoped (implies building-scoped as well)

  // Audit trail
  createdByMembershipId String? // Who uploaded/created (nullable for system docs)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  tenant              Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  file                File        @relation(fields: [fileId], references: [id], onDelete: Cascade)
  building            Building?   @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  unit                Unit?       @relation(fields: [unitId], references: [id], onDelete: Cascade)
  createdByMembership Membership? @relation(fields: [createdByMembershipId], references: [id], onDelete: SetNull)

  @@index([tenantId, category])
  @@index([tenantId, buildingId])
  @@index([tenantId, unitId])
  @@index([tenantId, visibility])
}

// ============================================================================
// Vendor: Proveedores (plomeros, electricistas, ascensoristas, etc.)
// ============================================================================
model Vendor {
  id        String   @id @default(cuid())
  tenantId  String
  name      String
  taxId     String? // RUT/CUIT/VAT número (nullable)
  email     String?
  phone     String?
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant        Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  assignments   VendorAssignment[]
  quotes        Quote[]
  workOrders    WorkOrder[]

  // Unique constraint to prevent duplicate vendors in same tenant
  @@unique([tenantId, name])
  @@index([tenantId, name])
}

// ============================================================================
// VendorAssignment: Asignación de proveedor a un building para servicio específico
// e.g., "Plomería Express" para edificio "Avenida 9 de Julio 100"
// ============================================================================
model VendorAssignment {
  id          String   @id @default(cuid())
  tenantId    String
  vendorId    String
  buildingId  String
  serviceType String // "PLUMBING", "ELECTRICITY", "ELEVATOR", "GENERAL", etc.
  createdAt   DateTime @default(now())

  // Relations
  tenant   Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  vendor   Vendor  @relation(fields: [vendorId], references: [id], onDelete: Restrict) // Can't delete vendor if assigned
  building Building @relation(fields: [buildingId], references: [id], onDelete: Cascade)

  // Unique: one vendor per building per service type
  @@unique([vendorId, buildingId, serviceType])
  @@index([tenantId, buildingId])
  @@index([tenantId, vendorId])
}

// ============================================================================
// Quote: Presupuestos/cotizaciones de proveedores
// Puede estar asociado opcionalmente a un ticket (reclamo)
// ============================================================================
model Quote {
  id        String      @id @default(cuid())
  tenantId  String
  buildingId String
  vendorId  String
  ticketId  String? // Optional: quote may not be tied to a specific ticket
  fileId    String? // Optional: PDF del presupuesto
  amount    Int // Amount in cents (e.g., 10000 = $100.00)
  currency  String      @default("ARS") // ARS, USD, etc.
  status    QuoteStatus @default(REQUESTED)
  notes     String?
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relations
  tenant  Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  building Building @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  vendor  Vendor   @relation(fields: [vendorId], references: [id], onDelete: Restrict) // Can't delete vendor if has quotes
  ticket  Ticket?  @relation(fields: [ticketId], references: [id], onDelete: SetNull) // Keep quote if ticket deleted
  file    File?    @relation(fields: [fileId], references: [id], onDelete: SetNull) // Keep quote if file deleted

  @@index([tenantId, buildingId, status])
  @@index([tenantId, ticketId])
  @@index([tenantId, vendorId])
}

// ============================================================================
// WorkOrder: Órdenes de trabajo (asignaciones de tareas a proveedores/operadores)
// Puede estar asociada opcionalmente a un ticket (reclamo)
// Puede estar asignada a un operador interno (Membership) o a un proveedor externo (Vendor)
// ============================================================================
model WorkOrder {
  id                     String           @id @default(cuid())
  tenantId               String
  buildingId             String
  ticketId               String? // Optional: work order may not be tied to a specific ticket
  vendorId               String? // Optional: external vendor (if null, assigned to operator)
  assignedToMembershipId String? // Optional: internal operator
  status                 WorkOrderStatus @default(OPEN)
  description           String?
  scheduledFor          DateTime? // When the work is scheduled to happen
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  closedAt              DateTime? // When the work was completed

  // Relations
  tenant         Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  building       Building    @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  ticket         Ticket?     @relation(fields: [ticketId], references: [id], onDelete: SetNull) // Keep work order if ticket deleted
  vendor         Vendor?     @relation(fields: [vendorId], references: [id], onDelete: SetNull) // Keep work order if vendor deleted
  assignedTo     Membership? @relation("WorkOrderAssignedTo", fields: [assignedToMembershipId], references: [id], onDelete: SetNull)

  @@index([tenantId, buildingId, status])
  @@index([tenantId, ticketId])
  @@index([assignedToMembershipId, status])
}

// ============================================================================
// FINANZAS: Charge (Cargo/Expensa por unidad)
// ============================================================================
model Charge {
  id                     String      @id @default(cuid())
  tenantId               String
  buildingId             String
  unitId                 String
  period                 String      // YYYY-MM format (e.g., "2026-02")
  type                   ChargeType  @default(COMMON_EXPENSE)
  concept                String      // e.g., "Expensas Comunes Febrero 2026"
  amount                 Int         // Amount in cents (e.g., 10000 = $100.00)
  currency               String      @default("ARS")
  dueDate                DateTime
  status                 ChargeStatus @default(PENDING)
  createdByMembershipId  String?     // Who created this charge (admin)
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  canceledAt             DateTime?

  // Relations
  tenant                Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  building              Building              @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  unit                  Unit                  @relation(fields: [unitId], references: [id], onDelete: Cascade)
  createdByMembership   Membership?           @relation(fields: [createdByMembershipId], references: [id], onDelete: SetNull)
  paymentAllocations    PaymentAllocation[]

  @@unique([unitId, period, concept]) // One charge per unit/period/concept
  @@index([tenantId, buildingId, period])
  @@index([tenantId, unitId, status])
  @@index([tenantId, buildingId, status])
  @@index([dueDate])
}

// ============================================================================
// FINANZAS: Payment (Pago de residente)
// ============================================================================
model Payment {
  id                       String         @id @default(cuid())
  tenantId                 String
  buildingId               String
  unitId                   String?        // Optional: payment may be for building (not unit-specific)
  amount                   Int            // Amount in cents
  currency                 String         @default("ARS")
  method                   PaymentMethod
  status                   PaymentStatus  @default(SUBMITTED)
  paidAt                   DateTime?      // When the payment was actually received
  reference                String?        // Payment reference (operation number, receipt)
  proofFileId              String?        // Link to proof document
  createdByUserId          String         // Who submitted the payment (resident)
  reviewedByMembershipId   String?        // Who approved the payment (admin)
  createdAt                DateTime        @default(now())
  updatedAt                DateTime        @updatedAt

  // Relations
  tenant                  Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  building                Building            @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  unit                    Unit?               @relation(fields: [unitId], references: [id], onDelete: SetNull)
  createdByUser           User                @relation("PaymentCreatedBy", fields: [createdByUserId], references: [id], onDelete: Restrict)
  reviewedByMembership    Membership?         @relation(fields: [reviewedByMembershipId], references: [id], onDelete: SetNull)
  proofFile               File?               @relation(fields: [proofFileId], references: [id], onDelete: SetNull)
  paymentAllocations      PaymentAllocation[]

  @@index([tenantId, buildingId, status])
  @@index([tenantId, unitId, status])
  @@index([tenantId, createdByUserId])
  @@index([status])
}

// ============================================================================
// FINANZAS: PaymentAllocation (Imputación de pago a cargo)
// ============================================================================
model PaymentAllocation {
  id        String   @id @default(cuid())
  tenantId  String
  paymentId String
  chargeId  String
  amount    Int      // Amount allocated (in cents, must be <= Payment.amount)
  createdAt DateTime @default(now())

  // Relations
  tenant    Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  payment   Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  charge    Charge  @relation(fields: [chargeId], references: [id], onDelete: Restrict) // Protect charge history

  @@unique([paymentId, chargeId]) // One allocation per payment/charge pair
  @@index([tenantId, paymentId])
  @@index([tenantId, chargeId])
}

// ============================================================================
// PHASE 10: ONBOARDING CHECKLIST
// ============================================================================
model OnboardingState {
  id          String    @id @default(cuid())
  tenantId    String    @unique
  dismissedAt DateTime? // Null = visible, timestamp = dismissed
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

// ============================================================================
// PHASE 11: EMAIL LOGGING & DELIVERY TRACKING
// ============================================================================
enum EmailType {
  INVITATION
  PASSWORD_RESET
  PAYMENT_SUBMITTED
}

model EmailLog {
  id           String    @id @default(cuid())
  tenantId     String?   // Optional if email not tenant-scoped
  type         EmailType
  to           String    // Recipient email
  subject      String
  status       String    // SENT | FAILED | BOUNCED
  error        String?   // Error message if failed
  provider     String    // SMTP, SENDGRID, MAILGUN
  externalId   String?   // Provider's message ID
  createdAt    DateTime  @default(now())
  sentAt       DateTime? // When email was actually sent

  // Relations
  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, type])
  @@index([tenantId, createdAt])
  @@index([to, createdAt])
}

// ============================================================================
// PHASE 11: NOTIFICATIONS (IN_APP + EMAIL)
// ============================================================================
enum NotificationType {
  TICKET_STATUS_CHANGED
  TICKET_COMMENT_ADDED
  SUPPORT_TICKET_CREATED
  SUPPORT_TICKET_STATUS_CHANGED
  USER_INVITED
  INVITATION_ACCEPTED
  PAYMENT_RECEIVED
  PAYMENT_OVERDUE
  DOCUMENT_SHARED
  BUILDING_ALERT
  OCCUPANT_ASSIGNED
  SYSTEM_ALERT
}

enum DeliveryMethod {
  IN_APP
  EMAIL
}

model Notification {
  id              String            @id @default(cuid())
  tenantId        String
  userId          String
  type            NotificationType
  title           String
  body            String
  data            Json?             // Additional context (ticketId, etc)
  deliveryMethods DeliveryMethod[]  // Default: [IN_APP]
  isRead          Boolean           @default(false)
  readAt          DateTime?
  createdAt       DateTime          @default(now())
  deletedAt       DateTime?         // Soft delete

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId, userId, isRead])
  @@index([userId, createdAt])
  @@index([tenantId, createdAt])
}

// ============================================================================
// PHASE 11: AI ASSISTANT (Premium Feature)
// ============================================================================

model AiInteractionLog {
  id           String   @id @default(cuid())
  tenantId     String
  userId       String
  membershipId String

  context      Json     // { buildingId?, unitId?, page }
  prompt       String
  response     Json     // { answer, suggestedActions }
  provider     String   // "MOCK", "OPENAI"
  tokensIn     Int?
  tokensOut    Int?

  createdAt    DateTime @default(now())

  // Relations
  tenant       Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  membership   Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)

  @@index([tenantId, createdAt])
  @@index([tenantId, userId, createdAt])
}

model TenantDailyAiUsage {
  id        String   @id @default(cuid())
  tenantId  String
  day       String   // "YYYY-MM-DD"
  count     Int      @default(0)
  updatedAt DateTime @updatedAt

  // Relations
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, day])
  @@index([tenantId])
}

model TenantAiBudget {
  id                    String   @id @default(cuid())
  tenantId              String   @unique
  monthlyBudgetCents    Int      @default(500) // $5/month default
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  monthlyUsage          TenantMonthlyAiUsage[]

  @@index([tenantId])
}

model TenantMonthlyAiUsage {
  id                    String    @id @default(cuid())
  tenantId              String
  budgetId              String
  month                 String    // "YYYY-MM"
  calls                 Int       @default(0)
  inputTokens           Int       @default(0)
  outputTokens          Int       @default(0)
  estimatedCostCents    Int       @default(0)
  warnedAt              DateTime?
  blockedAt             DateTime?
  updatedAt             DateTime  @updatedAt

  // Relations
  tenant                Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  budget                TenantAiBudget      @relation(fields: [budgetId], references: [id], onDelete: Cascade)

  @@unique([tenantId, month])
  @@index([tenantId, month])
  @@index([tenantId])
}
